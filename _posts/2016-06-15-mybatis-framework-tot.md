---
layout: post
title:  MyBatis知识点 - 框架综述
date:   2016-06-15 00:00:00 +0800
categories: MyBatis
tag: [MyBatis]
---

* content
{:toc}

### ORM ### 
> 解决面向对象语言和关系数据库不一致的问题  

&emsp;&emsp;关系数据库存储的是数据之间的关联关系，传统的操作JDBC来操作数据库时，往往需要拼接SQL处理结果之间的对应关系这些重复操作，持久层框架解决了这些问题，简化了代码的编写和实现了代码和程序的解耦，只关注对象，操作对象的方式来操作数据库。   


>  ORM框架结构分析：   
- 总体配置文件：驱动、连接、事务、其他属性配置等；   
- 从配置文件中获取sessionFactory；   
- 从sessionFactory中获取session；  
- 从session中完成对数据的增删改查和事务控制等；   
- 用完之后关闭session；  
- bean和数据表之间的一个映射关系文件   

----------------------

### 框架优缺点 ###
#### 使用JDBC开发时，对比MyBatis的不足  #### 
1、数据库连接，使用时创建，不使用就释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。   
解决方法：<strong>使用数据库连接池管理数据库连接</strong>   
2、sql语句使用硬编码在Java程序中，修改sql语句，就需要重新编译Java代码，不利于系统维护   
解决方法：<strong>把sql语句放在xml配置文件中</strong>，修改sql语句也不需要重新编译Java代码   
3、向预编译语句PreparedStatement中设置参数，对占位符位置和设置参数值，硬编码，修改sql语句也不需要重新编译java代码    
解决方法：把sql语句和<strong>占位符设置参数值</strong>放在xml配置文件中   
4、从result中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码   
解决方法：将查询的结果集，自动<strong>映射成Java对象</strong>   



#### JDBC到MyBatis优化改进 ####
##### 1、JDBC查询数据库数据的七个步骤  ##### 
>  一般步骤如下：  
（1） 加载驱动  
（2） 建立并获取数据库连接  
（3） 创建JDBC Statement对象  
（4） 设置SQL语句的传入参数  
（5） 执行SQL语句并获得查询结果  
（6） 对查询结果进行转换处理并返回  
（7） 释放资源（Connection、Statement、ResultSet）

&emsp;&emsp;<i>实现JDBC有七个步骤，哪些步骤可以进一步封装呢？</i>

##### 2、JDBC演变成MyBatis #####
第一步优化：连接获取和释放   
&emsp;&emsp;问题描述：通过JDBC的方式数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能；但是现在连接池多种多样，可能存在变化，有可能采用DBCP的连接池，也有可能采用容器本身的JNDI数据库连接池。   
&emsp;&emsp;<strong>解决问题</strong>：数据库连接的获取和关闭我们可以使用数据库连接池来解决资源浪费的问题，通过<b>连接池</b>就可以反复利用已经建立的连接去访问数据库了，减少连接的开启和关闭的时间。   
&emsp;&emsp;同时通过DataSource进行隔离解耦，统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，将DataSource的具体实现通过让用户配置来应对变化。   

第二步优化：SQL统一存取   
&emsp;&emsp;问题描述：通过JDBC的方式，可读性很差，不利于维护以及做性能调优；改动Java代码需要重新编译、打包部署。不利于取出SQL在数据库客户端执行（取出后还得删掉中间的Java代码，编写好的SQL语句写好后还得通过＋号在Java进行拼凑）。   
&emsp;&emsp;<strong>解决问题</strong>：把SQL语句统一集中放到配置文件，通过SQL语句的key值去获取对应的SQL语句。   
   
第三步优化：传入参数映射和动态SQL   
&emsp;&emsp;问题描述：很多情况下，我们都可以通过在SQL语句中设置占位符来达到使用传入参数的目的，这种方式本身就有一定局限性，它是按照一定顺序传入 参数的，要与占位符一一匹配。但是，如果我们传入的参数是不确定的（比如列表查询，根据用户填写的查询条件不同，传入查询的参数也是不同的，有时是一个参 数、有时可能是三个参数），那么我们就得在后台代码中自己根据请求的传入参数去拼凑相应的SQL语句，这样的话还是避免不了在Java代码里面写SQL语句的命运。   
&emsp;&emsp;<strong>解决问题</strong>：通过专门的SQL解析器来解析SQL语句，SQL语句经过解析后就可以动态的生成符合上下文的SQL语句，同时使用#变量名#表示占位符变量，使用$变量名$表示非占位符变量   

第四步优化：结果映射和结果缓存   
&emsp;&emsp;问题描述：执行SQL语句、获取执行结果、对执行结果进行转换处理、释放相关资源是一整套下来的。假如是执行查询语句，那么执行SQL语句后， 返回的是一个ResultSet结果集，这个时候我们就需要将ResultSet对象的数据取出来，不然等到释放资源时就取不到这些结果信息了。我们从前 面的优化来看，以及将获取连接、设置传入参数、执行SQL语句、释放资源这些都封装起来了，只剩下结果处理这块还没有进行封装，如果能封装起来，每个数据 库操作都不用自己写那么一大堆Java代码，直接调用一个封装的方法就可以搞定了     
&emsp;&emsp;<strong>解决问题</strong>：一般对执行结果的有哪些处理，有可能将结果不做任何处理就直接返回，也有可能将结果转换成一个JavaBean对象返回、一个Map 返回、一个List返回等等，结果处理可能是多种多样的。从这里看，我们必须告诉SQL处理器两点：第一，需要返回什么类型的对象；第二，需要返回的对象 的数据结构怎么跟执行的结果映射，这样才能将具体的值copy到对应的数据结构上。     

第五步、缓存优化：key-value内存数据库来缓存处理结果   
&emsp;&emsp;缓存数据都是key-value的格式，那么这个key怎么来呢？怎么保证唯一呢？即使同一 条SQL语句几次访问的过程中由于传入参数的不同，得到的执行SQL语句也是不同的。那么缓存起来的时候是多对。但是SQL语句和传入参数两部分合起来可 以作为数据缓存的key值。   
第六步优化：解决重复SQL语句问题   
&emsp;&emsp;问题描述：将所有SQL语句都放到配置文件中，这个时候会遇到一个SQL重复的问题，几个功能的SQL语句其实都差不多，有些可能是SELECT后面那段不同、有些可能是WHERE语句不同。有时候表结构改了，那么我们就需要改多个地方，不利于维护。   
&emsp;&emsp;<strong>解决问题</strong>：通过将SQL片段模块化，将重复的SQL片段独立成一个SQL块，然后在各个SQL语句引用重复的SQL块，这样需要修改时只需要修改一处即可。  



##### 3、优化的总结   #####
>  对JDBC的优化和封装：   
（1） 使用连接池对连接进行管理   
（2） SQL语句统一存放到配置文件   
（3） SQL语句变量和传入参数的映射以及动态SQL   
（4） 动态SQL语句的处理   
（5） 对数据库操作结果的映射和结果缓存   
（6） SQL语句的重复使用   

------------------------

### MyBatis框架 ###
&emsp;&emsp;MyBatis将主要精力放在sql上，通过MyBatis提供的映射方式，自动生成满足需要的sql语句   
&emsp;&emsp;MyBatis可以向PreparedStatement中输入参数自动进行输入映射，将查询结果集灵活的映射成Java对象（输出映射），输入映射和输出映射是MyBatis的核心   

#### 1、总体流程 ####
![](http://or9g8eqm7.bkt.clouddn.com/17-7-15/81425229.jpg)

> <b>(1) 加载配置并初始化</b>   
&emsp;&emsp;<b>触发条件：</b>加载配置文件   
&emsp;&emsp;配置来源于两个地方:配置文件、Java代码注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。   
<b>(2) 接收调用请求</b>   
&emsp;&emsp;<b>触发条件：</b>调用MyBatis提供的API    
&emsp;&emsp;<b>传入参数：</b>为SQL的ID和传入参数对象  
&emsp;&emsp;<b>处理过程：</b>将请求传递给下层的请求处理层进行处理   
<b>(3) 处理操作请求</b>   
&emsp;&emsp;<b>触发条件：</b>API接口层传递请求过来       
&emsp;&emsp;<b>传入参数：</b>为SQL的ID和传入参数对象  
&emsp;&emsp;<b>处理过程：</b>  
&emsp;&emsp;a、根据SQL的ID查找对应的MappedStatement对象。   
&emsp;&emsp;b、根据传入参数对象解析MappedStatement对象，得到最终要执行的SQL和执行传入参数。   
&emsp;&emsp;c、获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。   
&emsp;&emsp;d、根据MappedStatement对象中的结果映射配置对执行结果进行转换，并得到最终的处理结果。   
&emsp;&emsp;e、释放连接资源。   
<b>(4) 返回结果处理</b>   
&emsp;&emsp;将最终的处理结果返回   

#### 2、功能架构设计  ####

![](http://or9g8eqm7.bkt.clouddn.com/17-7-15/51036794.jpg)

![](http://or9g8eqm7.bkt.clouddn.com/17-7-15/12242132.jpg)

>   <b>把MyBatis的功能架构分为三层：</b>   
+ <b>API接口层</b>：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一旦接收到调用请求就会调用数据处理层来完成具体的数据处理。   
+ <b>数据处理层</b>：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。   
+ <b>基础支撑层</b>：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。   

#### 3、框架结构设计 ####
![](http://or9g8eqm7.bkt.clouddn.com/17-7-15/75353347.jpg)

>   <b>框架架构：</b>   
+ <b>加载配置</b>：配置来源于两个地方：配置文件、Java代码注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。   
+ <b>SQL解析</b>：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。  
+ <b>SQL执行</b>：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。   
+ <b>结果映射</b>：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。      